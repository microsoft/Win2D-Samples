// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.210806.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Canvas_UI_Composition_H
#define WINRT_Microsoft_Graphics_Canvas_UI_Composition_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.210806.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.210806.1"
#include "winrt/Microsoft.Graphics.Canvas.UI.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.2.h"
#include "winrt/impl/Microsoft.UI.Composition.2.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.UI.Composition.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::UI::Composition::CompositionGraphicsDevice) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::CreateCompositionGraphicsDevice(winrt::Microsoft::UI::Composition::Compositor const& compositor, winrt::Microsoft::Graphics::Canvas::CanvasDevice const& canvasDevice) const
    {
        void* graphicsDevice{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->CreateCompositionGraphicsDevice(*(void**)(&compositor), *(void**)(&canvasDevice), &graphicsDevice));
        return winrt::Microsoft::UI::Composition::CompositionGraphicsDevice{ graphicsDevice, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::UI::Composition::ICompositionSurface) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::CreateCompositionSurfaceForSwapChain(winrt::Microsoft::UI::Composition::Compositor const& compositor, winrt::Microsoft::Graphics::Canvas::CanvasSwapChain const& swapChain) const
    {
        void* compositionSurface{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->CreateCompositionSurfaceForSwapChain(*(void**)(&compositor), *(void**)(&swapChain), &compositionSurface));
        return winrt::Microsoft::UI::Composition::ICompositionSurface{ compositionSurface, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Graphics::Canvas::CanvasDevice) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::GetCanvasDevice(winrt::Microsoft::UI::Composition::CompositionGraphicsDevice const& graphicsDevice) const
    {
        void* canvasDevice{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->GetCanvasDevice(*(void**)(&graphicsDevice), &canvasDevice));
        return winrt::Microsoft::Graphics::Canvas::CanvasDevice{ canvasDevice, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::SetCanvasDevice(winrt::Microsoft::UI::Composition::CompositionGraphicsDevice const& graphicsDevice, winrt::Microsoft::Graphics::Canvas::CanvasDevice const& canvasDevice) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->SetCanvasDevice(*(void**)(&graphicsDevice), *(void**)(&canvasDevice)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::CreateDrawingSession(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface) const
    {
        void* drawingSession{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->CreateDrawingSession(*(void**)(&drawingSurface), &drawingSession));
        return winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession{ drawingSession, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::CreateDrawingSession(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface, winrt::Windows::Foundation::Rect const& updateRect) const
    {
        void* drawingSession{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->CreateDrawingSessionWithUpdateRect(*(void**)(&drawingSurface), impl::bind_in(updateRect), &drawingSession));
        return winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession{ drawingSession, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::CreateDrawingSession(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface, winrt::Windows::Foundation::Rect const& updateRectInPixels, float dpi) const
    {
        void* drawingSession{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->CreateDrawingSessionWithUpdateRectAndDpi(*(void**)(&drawingSurface), impl::bind_in(updateRectInPixels), dpi, &drawingSession));
        return winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession{ drawingSession, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Graphics_Canvas_UI_Composition_ICanvasCompositionStatics<D>::Resize(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface, winrt::Windows::Foundation::Size const& sizeInPixels) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics)->Resize(*(void**)(&drawingSurface), impl::bind_in(sizeInPixels)));
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics> : produce_base<D, winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics>
    {
        int32_t __stdcall CreateCompositionGraphicsDevice(void* compositor, void* canvasDevice, void** graphicsDevice) noexcept final try
        {
            clear_abi(graphicsDevice);
            typename D::abi_guard guard(this->shim());
            *graphicsDevice = detach_from<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice>(this->shim().CreateCompositionGraphicsDevice(*reinterpret_cast<winrt::Microsoft::UI::Composition::Compositor const*>(&compositor), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasDevice const*>(&canvasDevice)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateCompositionSurfaceForSwapChain(void* compositor, void* swapChain, void** compositionSurface) noexcept final try
        {
            clear_abi(compositionSurface);
            typename D::abi_guard guard(this->shim());
            *compositionSurface = detach_from<winrt::Microsoft::UI::Composition::ICompositionSurface>(this->shim().CreateCompositionSurfaceForSwapChain(*reinterpret_cast<winrt::Microsoft::UI::Composition::Compositor const*>(&compositor), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasSwapChain const*>(&swapChain)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetCanvasDevice(void* graphicsDevice, void** canvasDevice) noexcept final try
        {
            clear_abi(canvasDevice);
            typename D::abi_guard guard(this->shim());
            *canvasDevice = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDevice>(this->shim().GetCanvasDevice(*reinterpret_cast<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice const*>(&graphicsDevice)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetCanvasDevice(void* graphicsDevice, void* canvasDevice) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetCanvasDevice(*reinterpret_cast<winrt::Microsoft::UI::Composition::CompositionGraphicsDevice const*>(&graphicsDevice), *reinterpret_cast<winrt::Microsoft::Graphics::Canvas::CanvasDevice const*>(&canvasDevice));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateDrawingSession(void* drawingSurface, void** drawingSession) noexcept final try
        {
            clear_abi(drawingSession);
            typename D::abi_guard guard(this->shim());
            *drawingSession = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession>(this->shim().CreateDrawingSession(*reinterpret_cast<winrt::Microsoft::UI::Composition::CompositionDrawingSurface const*>(&drawingSurface)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateDrawingSessionWithUpdateRect(void* drawingSurface, winrt::Windows::Foundation::Rect updateRect, void** drawingSession) noexcept final try
        {
            clear_abi(drawingSession);
            typename D::abi_guard guard(this->shim());
            *drawingSession = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession>(this->shim().CreateDrawingSession(*reinterpret_cast<winrt::Microsoft::UI::Composition::CompositionDrawingSurface const*>(&drawingSurface), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&updateRect)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateDrawingSessionWithUpdateRectAndDpi(void* drawingSurface, winrt::Windows::Foundation::Rect updateRectInPixels, float dpi, void** drawingSession) noexcept final try
        {
            clear_abi(drawingSession);
            typename D::abi_guard guard(this->shim());
            *drawingSession = detach_from<winrt::Microsoft::Graphics::Canvas::CanvasDrawingSession>(this->shim().CreateDrawingSession(*reinterpret_cast<winrt::Microsoft::UI::Composition::CompositionDrawingSurface const*>(&drawingSurface), *reinterpret_cast<winrt::Windows::Foundation::Rect const*>(&updateRectInPixels), dpi));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall Resize(void* drawingSurface, winrt::Windows::Foundation::Size sizeInPixels) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().Resize(*reinterpret_cast<winrt::Microsoft::UI::Composition::CompositionDrawingSurface const*>(&drawingSurface), *reinterpret_cast<winrt::Windows::Foundation::Size const*>(&sizeInPixels));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Canvas::UI::Composition
{
    inline auto CanvasComposition::CreateCompositionGraphicsDevice(winrt::Microsoft::UI::Composition::Compositor const& compositor, winrt::Microsoft::Graphics::Canvas::CanvasDevice const& canvasDevice)
    {
        return impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.CreateCompositionGraphicsDevice(compositor, canvasDevice); });
    }
    inline auto CanvasComposition::CreateCompositionSurfaceForSwapChain(winrt::Microsoft::UI::Composition::Compositor const& compositor, winrt::Microsoft::Graphics::Canvas::CanvasSwapChain const& swapChain)
    {
        return impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.CreateCompositionSurfaceForSwapChain(compositor, swapChain); });
    }
    inline auto CanvasComposition::GetCanvasDevice(winrt::Microsoft::UI::Composition::CompositionGraphicsDevice const& graphicsDevice)
    {
        return impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.GetCanvasDevice(graphicsDevice); });
    }
    inline auto CanvasComposition::SetCanvasDevice(winrt::Microsoft::UI::Composition::CompositionGraphicsDevice const& graphicsDevice, winrt::Microsoft::Graphics::Canvas::CanvasDevice const& canvasDevice)
    {
        impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.SetCanvasDevice(graphicsDevice, canvasDevice); });
    }
    inline auto CanvasComposition::CreateDrawingSession(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface)
    {
        return impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.CreateDrawingSession(drawingSurface); });
    }
    inline auto CanvasComposition::CreateDrawingSession(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface, winrt::Windows::Foundation::Rect const& updateRect)
    {
        return impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.CreateDrawingSession(drawingSurface, updateRect); });
    }
    inline auto CanvasComposition::CreateDrawingSession(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface, winrt::Windows::Foundation::Rect const& updateRectInPixels, float dpi)
    {
        return impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.CreateDrawingSession(drawingSurface, updateRectInPixels, dpi); });
    }
    inline auto CanvasComposition::Resize(winrt::Microsoft::UI::Composition::CompositionDrawingSurface const& drawingSurface, winrt::Windows::Foundation::Size const& sizeInPixels)
    {
        impl::call_factory<CanvasComposition, ICanvasCompositionStatics>([&](ICanvasCompositionStatics const& f) { return f.Resize(drawingSurface, sizeInPixels); });
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::UI::Composition::ICanvasCompositionStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::UI::Composition::CanvasComposition> : winrt::impl::hash_base {};
#endif
}
#endif
