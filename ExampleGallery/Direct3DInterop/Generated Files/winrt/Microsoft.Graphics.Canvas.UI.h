// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.210806.1

#pragma once
#ifndef WINRT_Microsoft_Graphics_Canvas_UI_H
#define WINRT_Microsoft_Graphics_Canvas_UI_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.210806.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.210806.1"
#include "winrt/Microsoft.Graphics.Canvas.h"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Microsoft.Graphics.Canvas.UI.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesReason) consume_Microsoft_Graphics_Canvas_UI_ICanvasCreateResourcesEventArgs<D>::Reason() const
    {
        winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesReason value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgs)->get_Reason(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Graphics_Canvas_UI_ICanvasCreateResourcesEventArgs<D>::TrackAsyncAction(winrt::Windows::Foundation::IAsyncAction const& action) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgs)->TrackAsyncAction(*(void**)(&action)));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::IAsyncAction) consume_Microsoft_Graphics_Canvas_UI_ICanvasCreateResourcesEventArgs<D>::GetTrackedAction() const
    {
        void* action{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgs)->GetTrackedAction(&action));
        return winrt::Windows::Foundation::IAsyncAction{ action, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesEventArgs) consume_Microsoft_Graphics_Canvas_UI_ICanvasCreateResourcesEventArgsFactory<D>::Create(winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesReason const& createResourcesReason) const
    {
        void* CreateResourcesEventArgs{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgsFactory)->Create(static_cast<int32_t>(createResourcesReason), &CreateResourcesEventArgs));
        return winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesEventArgs{ CreateResourcesEventArgs, take_ownership_from_abi };
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgs> : produce_base<D, winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgs>
    {
        int32_t __stdcall get_Reason(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesReason>(this->shim().Reason());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TrackAsyncAction(void* action) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().TrackAsyncAction(*reinterpret_cast<winrt::Windows::Foundation::IAsyncAction const*>(&action));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetTrackedAction(void** action) noexcept final try
        {
            clear_abi(action);
            typename D::abi_guard guard(this->shim());
            *action = detach_from<winrt::Windows::Foundation::IAsyncAction>(this->shim().GetTrackedAction());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgsFactory> : produce_base<D, winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgsFactory>
    {
        int32_t __stdcall Create(int32_t createResourcesReason, void** CreateResourcesEventArgs) noexcept final try
        {
            clear_abi(CreateResourcesEventArgs);
            typename D::abi_guard guard(this->shim());
            *CreateResourcesEventArgs = detach_from<winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesEventArgs>(this->shim().Create(*reinterpret_cast<winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesReason const*>(&createResourcesReason)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Graphics::Canvas::UI
{
    inline CanvasCreateResourcesEventArgs::CanvasCreateResourcesEventArgs(winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesReason const& createResourcesReason) :
        CanvasCreateResourcesEventArgs(impl::call_factory<CanvasCreateResourcesEventArgs, ICanvasCreateResourcesEventArgsFactory>([&](ICanvasCreateResourcesEventArgsFactory const& f) { return f.Create(createResourcesReason); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::UI::ICanvasCreateResourcesEventArgsFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Graphics::Canvas::UI::CanvasCreateResourcesEventArgs> : winrt::impl::hash_base {};
#endif
}
#endif
